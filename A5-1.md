# A5/1 Stream Cipher Implementation in Python
The provided Python code implements a simplified version of the **A5/1 stream cipher**. A5/1 is used in mobile communication systems (specifically GSM) for encrypting voice and data traffic. It generates a keystream that is XORed with plaintext data to produce ciphertext. The key aspect of this cipher is the use of three linear feedback shift registers (LFSRs) and a majority voting mechanism to control which registers are shifted on each iteration.

Hereâ€™s a breakdown of how the code works:

### 1. **Initialization (`__init__` function)**
The A5/1 cipher consists of three shift registers:
- `reg_x`: 19 bits
- `reg_y`: 22 bits
- `reg_z`: 23 bits

These registers are initialized with specific bit values (`reg_x`, `reg_y`, and `reg_z`).

### 2. **Majority Voting (`majority_vote` function)**
This function implements a majority voting mechanism using bits `X[8]`, `Y[10]`, and `Z[10]` from the three registers. The majority vote controls which registers will be shifted in each iteration. The function returns the majority value (1 or 0) based on the three bits:
- `(x & y) | (y & z) | (x & z)` is a Boolean expression that returns the majority of the three bits.

### 3. **Shifting the Registers (`shift_register` function)**
This function performs a shift on the given register. In a shift register, each bit is shifted to the right, and a new bit is computed based on "tap" positions in the register. The taps represent positions that are XORed to create feedback:
- For `reg_x`, taps are at positions `13`, `16`, `17`, and `18`.
- For `reg_y`, taps are at positions `20` and `21`.
- For `reg_z`, taps are at positions `7`, `20`, `21`, and `22`.

### 4. **Generating a Keystream Bit (`generate_keystream_bit` function)**
This function generates a single keystream bit by following these steps:
- **Majority Vote**: First, the majority function is called to determine whether each of the three registers should be shifted.
- **Shifting Registers**: Each register is conditionally shifted based on the majority bit (if the selected control bit of the register equals the majority bit, it is shifted).
- **Keystream Generation**: The keystream bit is generated by XORing the last bits of `reg_x`, `reg_y`, and `reg_z`.

### 5. **Running Multiple Iterations (`run_iterations` function)**
This function runs the cipher for a specified number of iterations:
- It generates a keystream bit for each iteration.
- After generating each bit, the current state of the registers (`reg_x`, `reg_y`, `reg_z`) is printed.
- The function collects the keystream bits in a list and returns them.

### 6. **Example Usage**
In the example at the end of the code:
- The registers `reg_x`, `reg_y`, and `reg_z` are initialized with specific 19-bit, 22-bit, and 23-bit values, respectively.
- The `A51Cipher` object is created with these initial values.
- The cipher is run for 3 iterations, and the generated keystream bits along with the updated register states are printed.

### Sample Output:
For 3 iterations, the output shows:
- The keystream bit generated in each iteration.
- The state of the three registers after each iteration.

## Python Code :
``` python
class A51Cipher:
    def __init__(self, reg_x, reg_y, reg_z):
        self.reg_x = reg_x  
        self.reg_y = reg_y  
        self.reg_z = reg_z  

    def majority_vote(self, x, y, z):
        return (x & y) | (y & z) | (x & z)

    def shift_register(self, reg, taps):
        feedback = reg[-1]  
        new_bit = feedback ^ taps  
        reg = [new_bit] + reg[:-1]  
        return reg

    def generate_keystream_bit(self):
        maj_bit = self.majority_vote(self.reg_x[8], self.reg_y[10], self.reg_z[10])
        taps_x = self.reg_x[13] ^ self.reg_x[16] ^ self.reg_x[17] ^ self.reg_x[18]  
        taps_y = self.reg_y[20] ^ self.reg_y[21]  
        taps_z = self.reg_z[7] ^ self.reg_z[20] ^ self.reg_z[21] ^ self.reg_z[22]  
        if self.reg_x[8] == maj_bit:
            self.reg_x = self.shift_register(self.reg_x, taps_x)
        if self.reg_y[10] == maj_bit:
            self.reg_y = self.shift_register(self.reg_y, taps_y)
        if self.reg_z[10] == maj_bit:
            self.reg_z = self.shift_register(self.reg_z, taps_z)
        keystream_bit = self.reg_x[-1] ^ self.reg_y[-1] ^ self.reg_z[-1]
        return keystream_bit

    def run_iterations(self, iterations):
        keystream = []
        for i in range(iterations):
            keystream_bit = self.generate_keystream_bit()
            keystream.append(keystream_bit)
            print(f"Iteration {i+1}: Keystream bit = {keystream_bit}")
            print(f"Register X: {self.reg_x}")
            print(f"Register Y: {self.reg_y}")
            print(f"Register Z: {self.reg_z}\n")
        return keystream

if __name__ == "__main__":
    reg_x = [1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1]
    reg_y = [0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1]
    reg_z = [1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1]
    a51 = A51Cipher(reg_x, reg_y, reg_z)
    keystream = a51.run_iterations(3)

